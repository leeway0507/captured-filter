// Code generated by ent, DO NOT EDIT.

package ent

import (
	"backend/ent/deliveryagency"
	"backend/ent/predicate"
	"backend/ent/product"
	"backend/ent/schema"
	"backend/ent/store"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDeliveryAgency = "DeliveryAgency"
	TypeProduct        = "Product"
	TypeStore          = "Store"
)

// DeliveryAgencyMutation represents an operation that mutates the DeliveryAgency nodes in the graph.
type DeliveryAgencyMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	country                *string
	_VAT_reduction_rate    *float64
	add_VAT_reduction_rate *float64
	shipping_fee           **schema.AgencyShippingFee
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*DeliveryAgency, error)
	predicates             []predicate.DeliveryAgency
}

var _ ent.Mutation = (*DeliveryAgencyMutation)(nil)

// deliveryagencyOption allows management of the mutation configuration using functional options.
type deliveryagencyOption func(*DeliveryAgencyMutation)

// newDeliveryAgencyMutation creates new mutation for the DeliveryAgency entity.
func newDeliveryAgencyMutation(c config, op Op, opts ...deliveryagencyOption) *DeliveryAgencyMutation {
	m := &DeliveryAgencyMutation{
		config:        c,
		op:            op,
		typ:           TypeDeliveryAgency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeliveryAgencyID sets the ID field of the mutation.
func withDeliveryAgencyID(id int) deliveryagencyOption {
	return func(m *DeliveryAgencyMutation) {
		var (
			err   error
			once  sync.Once
			value *DeliveryAgency
		)
		m.oldValue = func(ctx context.Context) (*DeliveryAgency, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeliveryAgency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeliveryAgency sets the old DeliveryAgency of the mutation.
func withDeliveryAgency(node *DeliveryAgency) deliveryagencyOption {
	return func(m *DeliveryAgencyMutation) {
		m.oldValue = func(context.Context) (*DeliveryAgency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeliveryAgencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeliveryAgencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeliveryAgencyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeliveryAgencyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeliveryAgency.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCountry sets the "country" field.
func (m *DeliveryAgencyMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *DeliveryAgencyMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the DeliveryAgency entity.
// If the DeliveryAgency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryAgencyMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *DeliveryAgencyMutation) ResetCountry() {
	m.country = nil
}

// SetVATReductionRate sets the "VAT_reduction_rate" field.
func (m *DeliveryAgencyMutation) SetVATReductionRate(f float64) {
	m._VAT_reduction_rate = &f
	m.add_VAT_reduction_rate = nil
}

// VATReductionRate returns the value of the "VAT_reduction_rate" field in the mutation.
func (m *DeliveryAgencyMutation) VATReductionRate() (r float64, exists bool) {
	v := m._VAT_reduction_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldVATReductionRate returns the old "VAT_reduction_rate" field's value of the DeliveryAgency entity.
// If the DeliveryAgency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryAgencyMutation) OldVATReductionRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVATReductionRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVATReductionRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVATReductionRate: %w", err)
	}
	return oldValue.VATReductionRate, nil
}

// AddVATReductionRate adds f to the "VAT_reduction_rate" field.
func (m *DeliveryAgencyMutation) AddVATReductionRate(f float64) {
	if m.add_VAT_reduction_rate != nil {
		*m.add_VAT_reduction_rate += f
	} else {
		m.add_VAT_reduction_rate = &f
	}
}

// AddedVATReductionRate returns the value that was added to the "VAT_reduction_rate" field in this mutation.
func (m *DeliveryAgencyMutation) AddedVATReductionRate() (r float64, exists bool) {
	v := m.add_VAT_reduction_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetVATReductionRate resets all changes to the "VAT_reduction_rate" field.
func (m *DeliveryAgencyMutation) ResetVATReductionRate() {
	m._VAT_reduction_rate = nil
	m.add_VAT_reduction_rate = nil
}

// SetShippingFee sets the "shipping_fee" field.
func (m *DeliveryAgencyMutation) SetShippingFee(ssf *schema.AgencyShippingFee) {
	m.shipping_fee = &ssf
}

// ShippingFee returns the value of the "shipping_fee" field in the mutation.
func (m *DeliveryAgencyMutation) ShippingFee() (r *schema.AgencyShippingFee, exists bool) {
	v := m.shipping_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingFee returns the old "shipping_fee" field's value of the DeliveryAgency entity.
// If the DeliveryAgency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryAgencyMutation) OldShippingFee(ctx context.Context) (v *schema.AgencyShippingFee, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShippingFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShippingFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingFee: %w", err)
	}
	return oldValue.ShippingFee, nil
}

// ResetShippingFee resets all changes to the "shipping_fee" field.
func (m *DeliveryAgencyMutation) ResetShippingFee() {
	m.shipping_fee = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeliveryAgencyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeliveryAgencyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeliveryAgency entity.
// If the DeliveryAgency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryAgencyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeliveryAgencyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the DeliveryAgencyMutation builder.
func (m *DeliveryAgencyMutation) Where(ps ...predicate.DeliveryAgency) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeliveryAgencyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeliveryAgencyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeliveryAgency, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeliveryAgencyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeliveryAgencyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeliveryAgency).
func (m *DeliveryAgencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeliveryAgencyMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.country != nil {
		fields = append(fields, deliveryagency.FieldCountry)
	}
	if m._VAT_reduction_rate != nil {
		fields = append(fields, deliveryagency.FieldVATReductionRate)
	}
	if m.shipping_fee != nil {
		fields = append(fields, deliveryagency.FieldShippingFee)
	}
	if m.updated_at != nil {
		fields = append(fields, deliveryagency.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeliveryAgencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deliveryagency.FieldCountry:
		return m.Country()
	case deliveryagency.FieldVATReductionRate:
		return m.VATReductionRate()
	case deliveryagency.FieldShippingFee:
		return m.ShippingFee()
	case deliveryagency.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeliveryAgencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deliveryagency.FieldCountry:
		return m.OldCountry(ctx)
	case deliveryagency.FieldVATReductionRate:
		return m.OldVATReductionRate(ctx)
	case deliveryagency.FieldShippingFee:
		return m.OldShippingFee(ctx)
	case deliveryagency.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown DeliveryAgency field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliveryAgencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deliveryagency.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case deliveryagency.FieldVATReductionRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVATReductionRate(v)
		return nil
	case deliveryagency.FieldShippingFee:
		v, ok := value.(*schema.AgencyShippingFee)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingFee(v)
		return nil
	case deliveryagency.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown DeliveryAgency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeliveryAgencyMutation) AddedFields() []string {
	var fields []string
	if m.add_VAT_reduction_rate != nil {
		fields = append(fields, deliveryagency.FieldVATReductionRate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeliveryAgencyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case deliveryagency.FieldVATReductionRate:
		return m.AddedVATReductionRate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliveryAgencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case deliveryagency.FieldVATReductionRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVATReductionRate(v)
		return nil
	}
	return fmt.Errorf("unknown DeliveryAgency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeliveryAgencyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeliveryAgencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeliveryAgencyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DeliveryAgency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeliveryAgencyMutation) ResetField(name string) error {
	switch name {
	case deliveryagency.FieldCountry:
		m.ResetCountry()
		return nil
	case deliveryagency.FieldVATReductionRate:
		m.ResetVATReductionRate()
		return nil
	case deliveryagency.FieldShippingFee:
		m.ResetShippingFee()
		return nil
	case deliveryagency.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown DeliveryAgency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeliveryAgencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeliveryAgencyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeliveryAgencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeliveryAgencyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeliveryAgencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeliveryAgencyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeliveryAgencyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DeliveryAgency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeliveryAgencyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DeliveryAgency edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op               Op
	typ              string
	id               *int
	brand            *string
	product_name     *string
	product_img_url  *string
	product_url      *string
	currency_code    *string
	retail_price     *float64
	addretail_price  *float64
	sale_price       *float64
	addsale_price    *float64
	is_sale          *bool
	made_in          *string
	kor_brand        *string
	kor_product_name *string
	product_id       *string
	gender           *string
	color            *string
	category         *string
	category_spec    *string
	sold_out         *bool
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	store            *string
	clearedstore     bool
	done             bool
	oldValue         func(context.Context) (*Product, error)
	predicates       []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id int) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Product.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStoreName sets the "store_name" field.
func (m *ProductMutation) SetStoreName(s string) {
	m.store = &s
}

// StoreName returns the value of the "store_name" field in the mutation.
func (m *ProductMutation) StoreName() (r string, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreName returns the old "store_name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldStoreName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreName: %w", err)
	}
	return oldValue.StoreName, nil
}

// ClearStoreName clears the value of the "store_name" field.
func (m *ProductMutation) ClearStoreName() {
	m.store = nil
	m.clearedFields[product.FieldStoreName] = struct{}{}
}

// StoreNameCleared returns if the "store_name" field was cleared in this mutation.
func (m *ProductMutation) StoreNameCleared() bool {
	_, ok := m.clearedFields[product.FieldStoreName]
	return ok
}

// ResetStoreName resets all changes to the "store_name" field.
func (m *ProductMutation) ResetStoreName() {
	m.store = nil
	delete(m.clearedFields, product.FieldStoreName)
}

// SetBrand sets the "brand" field.
func (m *ProductMutation) SetBrand(s string) {
	m.brand = &s
}

// Brand returns the value of the "brand" field in the mutation.
func (m *ProductMutation) Brand() (r string, exists bool) {
	v := m.brand
	if v == nil {
		return
	}
	return *v, true
}

// OldBrand returns the old "brand" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldBrand(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrand: %w", err)
	}
	return oldValue.Brand, nil
}

// ResetBrand resets all changes to the "brand" field.
func (m *ProductMutation) ResetBrand() {
	m.brand = nil
}

// SetProductName sets the "product_name" field.
func (m *ProductMutation) SetProductName(s string) {
	m.product_name = &s
}

// ProductName returns the value of the "product_name" field in the mutation.
func (m *ProductMutation) ProductName() (r string, exists bool) {
	v := m.product_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProductName returns the old "product_name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldProductName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductName: %w", err)
	}
	return oldValue.ProductName, nil
}

// ResetProductName resets all changes to the "product_name" field.
func (m *ProductMutation) ResetProductName() {
	m.product_name = nil
}

// SetProductImgURL sets the "product_img_url" field.
func (m *ProductMutation) SetProductImgURL(s string) {
	m.product_img_url = &s
}

// ProductImgURL returns the value of the "product_img_url" field in the mutation.
func (m *ProductMutation) ProductImgURL() (r string, exists bool) {
	v := m.product_img_url
	if v == nil {
		return
	}
	return *v, true
}

// OldProductImgURL returns the old "product_img_url" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldProductImgURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductImgURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductImgURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductImgURL: %w", err)
	}
	return oldValue.ProductImgURL, nil
}

// ResetProductImgURL resets all changes to the "product_img_url" field.
func (m *ProductMutation) ResetProductImgURL() {
	m.product_img_url = nil
}

// SetProductURL sets the "product_url" field.
func (m *ProductMutation) SetProductURL(s string) {
	m.product_url = &s
}

// ProductURL returns the value of the "product_url" field in the mutation.
func (m *ProductMutation) ProductURL() (r string, exists bool) {
	v := m.product_url
	if v == nil {
		return
	}
	return *v, true
}

// OldProductURL returns the old "product_url" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldProductURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductURL: %w", err)
	}
	return oldValue.ProductURL, nil
}

// ResetProductURL resets all changes to the "product_url" field.
func (m *ProductMutation) ResetProductURL() {
	m.product_url = nil
}

// SetCurrencyCode sets the "currency_code" field.
func (m *ProductMutation) SetCurrencyCode(s string) {
	m.currency_code = &s
}

// CurrencyCode returns the value of the "currency_code" field in the mutation.
func (m *ProductMutation) CurrencyCode() (r string, exists bool) {
	v := m.currency_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrencyCode returns the old "currency_code" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCurrencyCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrencyCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrencyCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrencyCode: %w", err)
	}
	return oldValue.CurrencyCode, nil
}

// ResetCurrencyCode resets all changes to the "currency_code" field.
func (m *ProductMutation) ResetCurrencyCode() {
	m.currency_code = nil
}

// SetRetailPrice sets the "retail_price" field.
func (m *ProductMutation) SetRetailPrice(f float64) {
	m.retail_price = &f
	m.addretail_price = nil
}

// RetailPrice returns the value of the "retail_price" field in the mutation.
func (m *ProductMutation) RetailPrice() (r float64, exists bool) {
	v := m.retail_price
	if v == nil {
		return
	}
	return *v, true
}

// OldRetailPrice returns the old "retail_price" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldRetailPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetailPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetailPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetailPrice: %w", err)
	}
	return oldValue.RetailPrice, nil
}

// AddRetailPrice adds f to the "retail_price" field.
func (m *ProductMutation) AddRetailPrice(f float64) {
	if m.addretail_price != nil {
		*m.addretail_price += f
	} else {
		m.addretail_price = &f
	}
}

// AddedRetailPrice returns the value that was added to the "retail_price" field in this mutation.
func (m *ProductMutation) AddedRetailPrice() (r float64, exists bool) {
	v := m.addretail_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetRetailPrice resets all changes to the "retail_price" field.
func (m *ProductMutation) ResetRetailPrice() {
	m.retail_price = nil
	m.addretail_price = nil
}

// SetSalePrice sets the "sale_price" field.
func (m *ProductMutation) SetSalePrice(f float64) {
	m.sale_price = &f
	m.addsale_price = nil
}

// SalePrice returns the value of the "sale_price" field in the mutation.
func (m *ProductMutation) SalePrice() (r float64, exists bool) {
	v := m.sale_price
	if v == nil {
		return
	}
	return *v, true
}

// OldSalePrice returns the old "sale_price" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSalePrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalePrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalePrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalePrice: %w", err)
	}
	return oldValue.SalePrice, nil
}

// AddSalePrice adds f to the "sale_price" field.
func (m *ProductMutation) AddSalePrice(f float64) {
	if m.addsale_price != nil {
		*m.addsale_price += f
	} else {
		m.addsale_price = &f
	}
}

// AddedSalePrice returns the value that was added to the "sale_price" field in this mutation.
func (m *ProductMutation) AddedSalePrice() (r float64, exists bool) {
	v := m.addsale_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetSalePrice resets all changes to the "sale_price" field.
func (m *ProductMutation) ResetSalePrice() {
	m.sale_price = nil
	m.addsale_price = nil
}

// SetIsSale sets the "is_sale" field.
func (m *ProductMutation) SetIsSale(b bool) {
	m.is_sale = &b
}

// IsSale returns the value of the "is_sale" field in the mutation.
func (m *ProductMutation) IsSale() (r bool, exists bool) {
	v := m.is_sale
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSale returns the old "is_sale" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldIsSale(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSale: %w", err)
	}
	return oldValue.IsSale, nil
}

// ResetIsSale resets all changes to the "is_sale" field.
func (m *ProductMutation) ResetIsSale() {
	m.is_sale = nil
}

// SetMadeIn sets the "made_in" field.
func (m *ProductMutation) SetMadeIn(s string) {
	m.made_in = &s
}

// MadeIn returns the value of the "made_in" field in the mutation.
func (m *ProductMutation) MadeIn() (r string, exists bool) {
	v := m.made_in
	if v == nil {
		return
	}
	return *v, true
}

// OldMadeIn returns the old "made_in" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldMadeIn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMadeIn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMadeIn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMadeIn: %w", err)
	}
	return oldValue.MadeIn, nil
}

// ClearMadeIn clears the value of the "made_in" field.
func (m *ProductMutation) ClearMadeIn() {
	m.made_in = nil
	m.clearedFields[product.FieldMadeIn] = struct{}{}
}

// MadeInCleared returns if the "made_in" field was cleared in this mutation.
func (m *ProductMutation) MadeInCleared() bool {
	_, ok := m.clearedFields[product.FieldMadeIn]
	return ok
}

// ResetMadeIn resets all changes to the "made_in" field.
func (m *ProductMutation) ResetMadeIn() {
	m.made_in = nil
	delete(m.clearedFields, product.FieldMadeIn)
}

// SetKorBrand sets the "kor_brand" field.
func (m *ProductMutation) SetKorBrand(s string) {
	m.kor_brand = &s
}

// KorBrand returns the value of the "kor_brand" field in the mutation.
func (m *ProductMutation) KorBrand() (r string, exists bool) {
	v := m.kor_brand
	if v == nil {
		return
	}
	return *v, true
}

// OldKorBrand returns the old "kor_brand" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldKorBrand(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKorBrand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKorBrand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKorBrand: %w", err)
	}
	return oldValue.KorBrand, nil
}

// ClearKorBrand clears the value of the "kor_brand" field.
func (m *ProductMutation) ClearKorBrand() {
	m.kor_brand = nil
	m.clearedFields[product.FieldKorBrand] = struct{}{}
}

// KorBrandCleared returns if the "kor_brand" field was cleared in this mutation.
func (m *ProductMutation) KorBrandCleared() bool {
	_, ok := m.clearedFields[product.FieldKorBrand]
	return ok
}

// ResetKorBrand resets all changes to the "kor_brand" field.
func (m *ProductMutation) ResetKorBrand() {
	m.kor_brand = nil
	delete(m.clearedFields, product.FieldKorBrand)
}

// SetKorProductName sets the "kor_product_name" field.
func (m *ProductMutation) SetKorProductName(s string) {
	m.kor_product_name = &s
}

// KorProductName returns the value of the "kor_product_name" field in the mutation.
func (m *ProductMutation) KorProductName() (r string, exists bool) {
	v := m.kor_product_name
	if v == nil {
		return
	}
	return *v, true
}

// OldKorProductName returns the old "kor_product_name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldKorProductName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKorProductName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKorProductName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKorProductName: %w", err)
	}
	return oldValue.KorProductName, nil
}

// ClearKorProductName clears the value of the "kor_product_name" field.
func (m *ProductMutation) ClearKorProductName() {
	m.kor_product_name = nil
	m.clearedFields[product.FieldKorProductName] = struct{}{}
}

// KorProductNameCleared returns if the "kor_product_name" field was cleared in this mutation.
func (m *ProductMutation) KorProductNameCleared() bool {
	_, ok := m.clearedFields[product.FieldKorProductName]
	return ok
}

// ResetKorProductName resets all changes to the "kor_product_name" field.
func (m *ProductMutation) ResetKorProductName() {
	m.kor_product_name = nil
	delete(m.clearedFields, product.FieldKorProductName)
}

// SetProductID sets the "product_id" field.
func (m *ProductMutation) SetProductID(s string) {
	m.product_id = &s
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *ProductMutation) ProductID() (r string, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldProductID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ClearProductID clears the value of the "product_id" field.
func (m *ProductMutation) ClearProductID() {
	m.product_id = nil
	m.clearedFields[product.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *ProductMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[product.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *ProductMutation) ResetProductID() {
	m.product_id = nil
	delete(m.clearedFields, product.FieldProductID)
}

// SetGender sets the "gender" field.
func (m *ProductMutation) SetGender(s string) {
	m.gender = &s
}

// Gender returns the value of the "gender" field in the mutation.
func (m *ProductMutation) Gender() (r string, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ClearGender clears the value of the "gender" field.
func (m *ProductMutation) ClearGender() {
	m.gender = nil
	m.clearedFields[product.FieldGender] = struct{}{}
}

// GenderCleared returns if the "gender" field was cleared in this mutation.
func (m *ProductMutation) GenderCleared() bool {
	_, ok := m.clearedFields[product.FieldGender]
	return ok
}

// ResetGender resets all changes to the "gender" field.
func (m *ProductMutation) ResetGender() {
	m.gender = nil
	delete(m.clearedFields, product.FieldGender)
}

// SetColor sets the "color" field.
func (m *ProductMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *ProductMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *ProductMutation) ClearColor() {
	m.color = nil
	m.clearedFields[product.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *ProductMutation) ColorCleared() bool {
	_, ok := m.clearedFields[product.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *ProductMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, product.FieldColor)
}

// SetCategory sets the "category" field.
func (m *ProductMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ProductMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *ProductMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[product.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *ProductMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[product.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *ProductMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, product.FieldCategory)
}

// SetCategorySpec sets the "category_spec" field.
func (m *ProductMutation) SetCategorySpec(s string) {
	m.category_spec = &s
}

// CategorySpec returns the value of the "category_spec" field in the mutation.
func (m *ProductMutation) CategorySpec() (r string, exists bool) {
	v := m.category_spec
	if v == nil {
		return
	}
	return *v, true
}

// OldCategorySpec returns the old "category_spec" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCategorySpec(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategorySpec is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategorySpec requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategorySpec: %w", err)
	}
	return oldValue.CategorySpec, nil
}

// ClearCategorySpec clears the value of the "category_spec" field.
func (m *ProductMutation) ClearCategorySpec() {
	m.category_spec = nil
	m.clearedFields[product.FieldCategorySpec] = struct{}{}
}

// CategorySpecCleared returns if the "category_spec" field was cleared in this mutation.
func (m *ProductMutation) CategorySpecCleared() bool {
	_, ok := m.clearedFields[product.FieldCategorySpec]
	return ok
}

// ResetCategorySpec resets all changes to the "category_spec" field.
func (m *ProductMutation) ResetCategorySpec() {
	m.category_spec = nil
	delete(m.clearedFields, product.FieldCategorySpec)
}

// SetSoldOut sets the "sold_out" field.
func (m *ProductMutation) SetSoldOut(b bool) {
	m.sold_out = &b
}

// SoldOut returns the value of the "sold_out" field in the mutation.
func (m *ProductMutation) SoldOut() (r bool, exists bool) {
	v := m.sold_out
	if v == nil {
		return
	}
	return *v, true
}

// OldSoldOut returns the old "sold_out" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSoldOut(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSoldOut is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSoldOut requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSoldOut: %w", err)
	}
	return oldValue.SoldOut, nil
}

// ResetSoldOut resets all changes to the "sold_out" field.
func (m *ProductMutation) ResetSoldOut() {
	m.sold_out = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStoreID sets the "store" edge to the Store entity by id.
func (m *ProductMutation) SetStoreID(id string) {
	m.store = &id
}

// ClearStore clears the "store" edge to the Store entity.
func (m *ProductMutation) ClearStore() {
	m.clearedstore = true
	m.clearedFields[product.FieldStoreName] = struct{}{}
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *ProductMutation) StoreCleared() bool {
	return m.StoreNameCleared() || m.clearedstore
}

// StoreID returns the "store" edge ID in the mutation.
func (m *ProductMutation) StoreID() (id string, exists bool) {
	if m.store != nil {
		return *m.store, true
	}
	return
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) StoreIDs() (ids []string) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *ProductMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Product, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.store != nil {
		fields = append(fields, product.FieldStoreName)
	}
	if m.brand != nil {
		fields = append(fields, product.FieldBrand)
	}
	if m.product_name != nil {
		fields = append(fields, product.FieldProductName)
	}
	if m.product_img_url != nil {
		fields = append(fields, product.FieldProductImgURL)
	}
	if m.product_url != nil {
		fields = append(fields, product.FieldProductURL)
	}
	if m.currency_code != nil {
		fields = append(fields, product.FieldCurrencyCode)
	}
	if m.retail_price != nil {
		fields = append(fields, product.FieldRetailPrice)
	}
	if m.sale_price != nil {
		fields = append(fields, product.FieldSalePrice)
	}
	if m.is_sale != nil {
		fields = append(fields, product.FieldIsSale)
	}
	if m.made_in != nil {
		fields = append(fields, product.FieldMadeIn)
	}
	if m.kor_brand != nil {
		fields = append(fields, product.FieldKorBrand)
	}
	if m.kor_product_name != nil {
		fields = append(fields, product.FieldKorProductName)
	}
	if m.product_id != nil {
		fields = append(fields, product.FieldProductID)
	}
	if m.gender != nil {
		fields = append(fields, product.FieldGender)
	}
	if m.color != nil {
		fields = append(fields, product.FieldColor)
	}
	if m.category != nil {
		fields = append(fields, product.FieldCategory)
	}
	if m.category_spec != nil {
		fields = append(fields, product.FieldCategorySpec)
	}
	if m.sold_out != nil {
		fields = append(fields, product.FieldSoldOut)
	}
	if m.updated_at != nil {
		fields = append(fields, product.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldStoreName:
		return m.StoreName()
	case product.FieldBrand:
		return m.Brand()
	case product.FieldProductName:
		return m.ProductName()
	case product.FieldProductImgURL:
		return m.ProductImgURL()
	case product.FieldProductURL:
		return m.ProductURL()
	case product.FieldCurrencyCode:
		return m.CurrencyCode()
	case product.FieldRetailPrice:
		return m.RetailPrice()
	case product.FieldSalePrice:
		return m.SalePrice()
	case product.FieldIsSale:
		return m.IsSale()
	case product.FieldMadeIn:
		return m.MadeIn()
	case product.FieldKorBrand:
		return m.KorBrand()
	case product.FieldKorProductName:
		return m.KorProductName()
	case product.FieldProductID:
		return m.ProductID()
	case product.FieldGender:
		return m.Gender()
	case product.FieldColor:
		return m.Color()
	case product.FieldCategory:
		return m.Category()
	case product.FieldCategorySpec:
		return m.CategorySpec()
	case product.FieldSoldOut:
		return m.SoldOut()
	case product.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldStoreName:
		return m.OldStoreName(ctx)
	case product.FieldBrand:
		return m.OldBrand(ctx)
	case product.FieldProductName:
		return m.OldProductName(ctx)
	case product.FieldProductImgURL:
		return m.OldProductImgURL(ctx)
	case product.FieldProductURL:
		return m.OldProductURL(ctx)
	case product.FieldCurrencyCode:
		return m.OldCurrencyCode(ctx)
	case product.FieldRetailPrice:
		return m.OldRetailPrice(ctx)
	case product.FieldSalePrice:
		return m.OldSalePrice(ctx)
	case product.FieldIsSale:
		return m.OldIsSale(ctx)
	case product.FieldMadeIn:
		return m.OldMadeIn(ctx)
	case product.FieldKorBrand:
		return m.OldKorBrand(ctx)
	case product.FieldKorProductName:
		return m.OldKorProductName(ctx)
	case product.FieldProductID:
		return m.OldProductID(ctx)
	case product.FieldGender:
		return m.OldGender(ctx)
	case product.FieldColor:
		return m.OldColor(ctx)
	case product.FieldCategory:
		return m.OldCategory(ctx)
	case product.FieldCategorySpec:
		return m.OldCategorySpec(ctx)
	case product.FieldSoldOut:
		return m.OldSoldOut(ctx)
	case product.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldStoreName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreName(v)
		return nil
	case product.FieldBrand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrand(v)
		return nil
	case product.FieldProductName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductName(v)
		return nil
	case product.FieldProductImgURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductImgURL(v)
		return nil
	case product.FieldProductURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductURL(v)
		return nil
	case product.FieldCurrencyCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrencyCode(v)
		return nil
	case product.FieldRetailPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetailPrice(v)
		return nil
	case product.FieldSalePrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalePrice(v)
		return nil
	case product.FieldIsSale:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSale(v)
		return nil
	case product.FieldMadeIn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMadeIn(v)
		return nil
	case product.FieldKorBrand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKorBrand(v)
		return nil
	case product.FieldKorProductName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKorProductName(v)
		return nil
	case product.FieldProductID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case product.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case product.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case product.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case product.FieldCategorySpec:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategorySpec(v)
		return nil
	case product.FieldSoldOut:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSoldOut(v)
		return nil
	case product.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	if m.addretail_price != nil {
		fields = append(fields, product.FieldRetailPrice)
	}
	if m.addsale_price != nil {
		fields = append(fields, product.FieldSalePrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case product.FieldRetailPrice:
		return m.AddedRetailPrice()
	case product.FieldSalePrice:
		return m.AddedSalePrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case product.FieldRetailPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRetailPrice(v)
		return nil
	case product.FieldSalePrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSalePrice(v)
		return nil
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(product.FieldStoreName) {
		fields = append(fields, product.FieldStoreName)
	}
	if m.FieldCleared(product.FieldMadeIn) {
		fields = append(fields, product.FieldMadeIn)
	}
	if m.FieldCleared(product.FieldKorBrand) {
		fields = append(fields, product.FieldKorBrand)
	}
	if m.FieldCleared(product.FieldKorProductName) {
		fields = append(fields, product.FieldKorProductName)
	}
	if m.FieldCleared(product.FieldProductID) {
		fields = append(fields, product.FieldProductID)
	}
	if m.FieldCleared(product.FieldGender) {
		fields = append(fields, product.FieldGender)
	}
	if m.FieldCleared(product.FieldColor) {
		fields = append(fields, product.FieldColor)
	}
	if m.FieldCleared(product.FieldCategory) {
		fields = append(fields, product.FieldCategory)
	}
	if m.FieldCleared(product.FieldCategorySpec) {
		fields = append(fields, product.FieldCategorySpec)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	switch name {
	case product.FieldStoreName:
		m.ClearStoreName()
		return nil
	case product.FieldMadeIn:
		m.ClearMadeIn()
		return nil
	case product.FieldKorBrand:
		m.ClearKorBrand()
		return nil
	case product.FieldKorProductName:
		m.ClearKorProductName()
		return nil
	case product.FieldProductID:
		m.ClearProductID()
		return nil
	case product.FieldGender:
		m.ClearGender()
		return nil
	case product.FieldColor:
		m.ClearColor()
		return nil
	case product.FieldCategory:
		m.ClearCategory()
		return nil
	case product.FieldCategorySpec:
		m.ClearCategorySpec()
		return nil
	}
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldStoreName:
		m.ResetStoreName()
		return nil
	case product.FieldBrand:
		m.ResetBrand()
		return nil
	case product.FieldProductName:
		m.ResetProductName()
		return nil
	case product.FieldProductImgURL:
		m.ResetProductImgURL()
		return nil
	case product.FieldProductURL:
		m.ResetProductURL()
		return nil
	case product.FieldCurrencyCode:
		m.ResetCurrencyCode()
		return nil
	case product.FieldRetailPrice:
		m.ResetRetailPrice()
		return nil
	case product.FieldSalePrice:
		m.ResetSalePrice()
		return nil
	case product.FieldIsSale:
		m.ResetIsSale()
		return nil
	case product.FieldMadeIn:
		m.ResetMadeIn()
		return nil
	case product.FieldKorBrand:
		m.ResetKorBrand()
		return nil
	case product.FieldKorProductName:
		m.ResetKorProductName()
		return nil
	case product.FieldProductID:
		m.ResetProductID()
		return nil
	case product.FieldGender:
		m.ResetGender()
		return nil
	case product.FieldColor:
		m.ResetColor()
		return nil
	case product.FieldCategory:
		m.ResetCategory()
		return nil
	case product.FieldCategorySpec:
		m.ResetCategorySpec()
		return nil
	case product.FieldSoldOut:
		m.ResetSoldOut()
		return nil
	case product.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.store != nil {
		edges = append(edges, product.EdgeStore)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstore {
		edges = append(edges, product.EdgeStore)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgeStore:
		return m.clearedstore
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	case product.EdgeStore:
		m.ClearStore()
		return nil
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgeStore:
		m.ResetStore()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}

// StoreMutation represents an operation that mutates the Store nodes in the graph.
type StoreMutation struct {
	config
	op                            Op
	typ                           string
	id                            *string
	kor_id                        *string
	url                           *string
	country                       *string
	currency                      *string
	tax_reduction                 *float64
	addtax_reduction              *float64
	tax_reduction_manually        *bool
	intl_shipping_fee             **schema.ShippingFee
	intl_free_shipping_min        *int
	addintl_free_shipping_min     *int
	domestic_shipping_fee         *float64
	adddomestic_shipping_fee      *float64
	domestic_free_shipping_min    *float64
	adddomestic_free_shipping_min *float64
	shipping_fee_cumulation       *bool
	delivery_agency               *string
	broker_fee                    *bool
	ddp                           *bool
	updated_at                    *time.Time
	clearedFields                 map[string]struct{}
	product                       map[int]struct{}
	removedproduct                map[int]struct{}
	clearedproduct                bool
	done                          bool
	oldValue                      func(context.Context) (*Store, error)
	predicates                    []predicate.Store
}

var _ ent.Mutation = (*StoreMutation)(nil)

// storeOption allows management of the mutation configuration using functional options.
type storeOption func(*StoreMutation)

// newStoreMutation creates new mutation for the Store entity.
func newStoreMutation(c config, op Op, opts ...storeOption) *StoreMutation {
	m := &StoreMutation{
		config:        c,
		op:            op,
		typ:           TypeStore,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStoreID sets the ID field of the mutation.
func withStoreID(id string) storeOption {
	return func(m *StoreMutation) {
		var (
			err   error
			once  sync.Once
			value *Store
		)
		m.oldValue = func(ctx context.Context) (*Store, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Store.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStore sets the old Store of the mutation.
func withStore(node *Store) storeOption {
	return func(m *StoreMutation) {
		m.oldValue = func(context.Context) (*Store, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StoreMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StoreMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Store entities.
func (m *StoreMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StoreMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StoreMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Store.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKorID sets the "kor_id" field.
func (m *StoreMutation) SetKorID(s string) {
	m.kor_id = &s
}

// KorID returns the value of the "kor_id" field in the mutation.
func (m *StoreMutation) KorID() (r string, exists bool) {
	v := m.kor_id
	if v == nil {
		return
	}
	return *v, true
}

// OldKorID returns the old "kor_id" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldKorID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKorID: %w", err)
	}
	return oldValue.KorID, nil
}

// ResetKorID resets all changes to the "kor_id" field.
func (m *StoreMutation) ResetKorID() {
	m.kor_id = nil
}

// SetURL sets the "url" field.
func (m *StoreMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *StoreMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *StoreMutation) ResetURL() {
	m.url = nil
}

// SetCountry sets the "country" field.
func (m *StoreMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *StoreMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *StoreMutation) ResetCountry() {
	m.country = nil
}

// SetCurrency sets the "currency" field.
func (m *StoreMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *StoreMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *StoreMutation) ResetCurrency() {
	m.currency = nil
}

// SetTaxReduction sets the "tax_reduction" field.
func (m *StoreMutation) SetTaxReduction(f float64) {
	m.tax_reduction = &f
	m.addtax_reduction = nil
}

// TaxReduction returns the value of the "tax_reduction" field in the mutation.
func (m *StoreMutation) TaxReduction() (r float64, exists bool) {
	v := m.tax_reduction
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxReduction returns the old "tax_reduction" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldTaxReduction(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxReduction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxReduction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxReduction: %w", err)
	}
	return oldValue.TaxReduction, nil
}

// AddTaxReduction adds f to the "tax_reduction" field.
func (m *StoreMutation) AddTaxReduction(f float64) {
	if m.addtax_reduction != nil {
		*m.addtax_reduction += f
	} else {
		m.addtax_reduction = &f
	}
}

// AddedTaxReduction returns the value that was added to the "tax_reduction" field in this mutation.
func (m *StoreMutation) AddedTaxReduction() (r float64, exists bool) {
	v := m.addtax_reduction
	if v == nil {
		return
	}
	return *v, true
}

// ResetTaxReduction resets all changes to the "tax_reduction" field.
func (m *StoreMutation) ResetTaxReduction() {
	m.tax_reduction = nil
	m.addtax_reduction = nil
}

// SetTaxReductionManually sets the "tax_reduction_manually" field.
func (m *StoreMutation) SetTaxReductionManually(b bool) {
	m.tax_reduction_manually = &b
}

// TaxReductionManually returns the value of the "tax_reduction_manually" field in the mutation.
func (m *StoreMutation) TaxReductionManually() (r bool, exists bool) {
	v := m.tax_reduction_manually
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxReductionManually returns the old "tax_reduction_manually" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldTaxReductionManually(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxReductionManually is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxReductionManually requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxReductionManually: %w", err)
	}
	return oldValue.TaxReductionManually, nil
}

// ResetTaxReductionManually resets all changes to the "tax_reduction_manually" field.
func (m *StoreMutation) ResetTaxReductionManually() {
	m.tax_reduction_manually = nil
}

// SetIntlShippingFee sets the "intl_shipping_fee" field.
func (m *StoreMutation) SetIntlShippingFee(sf *schema.ShippingFee) {
	m.intl_shipping_fee = &sf
}

// IntlShippingFee returns the value of the "intl_shipping_fee" field in the mutation.
func (m *StoreMutation) IntlShippingFee() (r *schema.ShippingFee, exists bool) {
	v := m.intl_shipping_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldIntlShippingFee returns the old "intl_shipping_fee" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldIntlShippingFee(ctx context.Context) (v *schema.ShippingFee, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntlShippingFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntlShippingFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntlShippingFee: %w", err)
	}
	return oldValue.IntlShippingFee, nil
}

// ResetIntlShippingFee resets all changes to the "intl_shipping_fee" field.
func (m *StoreMutation) ResetIntlShippingFee() {
	m.intl_shipping_fee = nil
}

// SetIntlFreeShippingMin sets the "intl_free_shipping_min" field.
func (m *StoreMutation) SetIntlFreeShippingMin(i int) {
	m.intl_free_shipping_min = &i
	m.addintl_free_shipping_min = nil
}

// IntlFreeShippingMin returns the value of the "intl_free_shipping_min" field in the mutation.
func (m *StoreMutation) IntlFreeShippingMin() (r int, exists bool) {
	v := m.intl_free_shipping_min
	if v == nil {
		return
	}
	return *v, true
}

// OldIntlFreeShippingMin returns the old "intl_free_shipping_min" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldIntlFreeShippingMin(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntlFreeShippingMin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntlFreeShippingMin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntlFreeShippingMin: %w", err)
	}
	return oldValue.IntlFreeShippingMin, nil
}

// AddIntlFreeShippingMin adds i to the "intl_free_shipping_min" field.
func (m *StoreMutation) AddIntlFreeShippingMin(i int) {
	if m.addintl_free_shipping_min != nil {
		*m.addintl_free_shipping_min += i
	} else {
		m.addintl_free_shipping_min = &i
	}
}

// AddedIntlFreeShippingMin returns the value that was added to the "intl_free_shipping_min" field in this mutation.
func (m *StoreMutation) AddedIntlFreeShippingMin() (r int, exists bool) {
	v := m.addintl_free_shipping_min
	if v == nil {
		return
	}
	return *v, true
}

// ResetIntlFreeShippingMin resets all changes to the "intl_free_shipping_min" field.
func (m *StoreMutation) ResetIntlFreeShippingMin() {
	m.intl_free_shipping_min = nil
	m.addintl_free_shipping_min = nil
}

// SetDomesticShippingFee sets the "domestic_shipping_fee" field.
func (m *StoreMutation) SetDomesticShippingFee(f float64) {
	m.domestic_shipping_fee = &f
	m.adddomestic_shipping_fee = nil
}

// DomesticShippingFee returns the value of the "domestic_shipping_fee" field in the mutation.
func (m *StoreMutation) DomesticShippingFee() (r float64, exists bool) {
	v := m.domestic_shipping_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldDomesticShippingFee returns the old "domestic_shipping_fee" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldDomesticShippingFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomesticShippingFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomesticShippingFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomesticShippingFee: %w", err)
	}
	return oldValue.DomesticShippingFee, nil
}

// AddDomesticShippingFee adds f to the "domestic_shipping_fee" field.
func (m *StoreMutation) AddDomesticShippingFee(f float64) {
	if m.adddomestic_shipping_fee != nil {
		*m.adddomestic_shipping_fee += f
	} else {
		m.adddomestic_shipping_fee = &f
	}
}

// AddedDomesticShippingFee returns the value that was added to the "domestic_shipping_fee" field in this mutation.
func (m *StoreMutation) AddedDomesticShippingFee() (r float64, exists bool) {
	v := m.adddomestic_shipping_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetDomesticShippingFee resets all changes to the "domestic_shipping_fee" field.
func (m *StoreMutation) ResetDomesticShippingFee() {
	m.domestic_shipping_fee = nil
	m.adddomestic_shipping_fee = nil
}

// SetDomesticFreeShippingMin sets the "domestic_free_shipping_min" field.
func (m *StoreMutation) SetDomesticFreeShippingMin(f float64) {
	m.domestic_free_shipping_min = &f
	m.adddomestic_free_shipping_min = nil
}

// DomesticFreeShippingMin returns the value of the "domestic_free_shipping_min" field in the mutation.
func (m *StoreMutation) DomesticFreeShippingMin() (r float64, exists bool) {
	v := m.domestic_free_shipping_min
	if v == nil {
		return
	}
	return *v, true
}

// OldDomesticFreeShippingMin returns the old "domestic_free_shipping_min" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldDomesticFreeShippingMin(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomesticFreeShippingMin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomesticFreeShippingMin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomesticFreeShippingMin: %w", err)
	}
	return oldValue.DomesticFreeShippingMin, nil
}

// AddDomesticFreeShippingMin adds f to the "domestic_free_shipping_min" field.
func (m *StoreMutation) AddDomesticFreeShippingMin(f float64) {
	if m.adddomestic_free_shipping_min != nil {
		*m.adddomestic_free_shipping_min += f
	} else {
		m.adddomestic_free_shipping_min = &f
	}
}

// AddedDomesticFreeShippingMin returns the value that was added to the "domestic_free_shipping_min" field in this mutation.
func (m *StoreMutation) AddedDomesticFreeShippingMin() (r float64, exists bool) {
	v := m.adddomestic_free_shipping_min
	if v == nil {
		return
	}
	return *v, true
}

// ResetDomesticFreeShippingMin resets all changes to the "domestic_free_shipping_min" field.
func (m *StoreMutation) ResetDomesticFreeShippingMin() {
	m.domestic_free_shipping_min = nil
	m.adddomestic_free_shipping_min = nil
}

// SetShippingFeeCumulation sets the "shipping_fee_cumulation" field.
func (m *StoreMutation) SetShippingFeeCumulation(b bool) {
	m.shipping_fee_cumulation = &b
}

// ShippingFeeCumulation returns the value of the "shipping_fee_cumulation" field in the mutation.
func (m *StoreMutation) ShippingFeeCumulation() (r bool, exists bool) {
	v := m.shipping_fee_cumulation
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingFeeCumulation returns the old "shipping_fee_cumulation" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldShippingFeeCumulation(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShippingFeeCumulation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShippingFeeCumulation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingFeeCumulation: %w", err)
	}
	return oldValue.ShippingFeeCumulation, nil
}

// ResetShippingFeeCumulation resets all changes to the "shipping_fee_cumulation" field.
func (m *StoreMutation) ResetShippingFeeCumulation() {
	m.shipping_fee_cumulation = nil
}

// SetDeliveryAgency sets the "delivery_agency" field.
func (m *StoreMutation) SetDeliveryAgency(s string) {
	m.delivery_agency = &s
}

// DeliveryAgency returns the value of the "delivery_agency" field in the mutation.
func (m *StoreMutation) DeliveryAgency() (r string, exists bool) {
	v := m.delivery_agency
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryAgency returns the old "delivery_agency" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldDeliveryAgency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryAgency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryAgency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryAgency: %w", err)
	}
	return oldValue.DeliveryAgency, nil
}

// ResetDeliveryAgency resets all changes to the "delivery_agency" field.
func (m *StoreMutation) ResetDeliveryAgency() {
	m.delivery_agency = nil
}

// SetBrokerFee sets the "broker_fee" field.
func (m *StoreMutation) SetBrokerFee(b bool) {
	m.broker_fee = &b
}

// BrokerFee returns the value of the "broker_fee" field in the mutation.
func (m *StoreMutation) BrokerFee() (r bool, exists bool) {
	v := m.broker_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldBrokerFee returns the old "broker_fee" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldBrokerFee(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrokerFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrokerFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrokerFee: %w", err)
	}
	return oldValue.BrokerFee, nil
}

// ResetBrokerFee resets all changes to the "broker_fee" field.
func (m *StoreMutation) ResetBrokerFee() {
	m.broker_fee = nil
}

// SetDdp sets the "ddp" field.
func (m *StoreMutation) SetDdp(b bool) {
	m.ddp = &b
}

// Ddp returns the value of the "ddp" field in the mutation.
func (m *StoreMutation) Ddp() (r bool, exists bool) {
	v := m.ddp
	if v == nil {
		return
	}
	return *v, true
}

// OldDdp returns the old "ddp" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldDdp(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDdp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDdp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDdp: %w", err)
	}
	return oldValue.Ddp, nil
}

// ResetDdp resets all changes to the "ddp" field.
func (m *StoreMutation) ResetDdp() {
	m.ddp = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StoreMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StoreMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StoreMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddProductIDs adds the "product" edge to the Product entity by ids.
func (m *StoreMutation) AddProductIDs(ids ...int) {
	if m.product == nil {
		m.product = make(map[int]struct{})
	}
	for i := range ids {
		m.product[ids[i]] = struct{}{}
	}
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *StoreMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *StoreMutation) ProductCleared() bool {
	return m.clearedproduct
}

// RemoveProductIDs removes the "product" edge to the Product entity by IDs.
func (m *StoreMutation) RemoveProductIDs(ids ...int) {
	if m.removedproduct == nil {
		m.removedproduct = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.product, ids[i])
		m.removedproduct[ids[i]] = struct{}{}
	}
}

// RemovedProduct returns the removed IDs of the "product" edge to the Product entity.
func (m *StoreMutation) RemovedProductIDs() (ids []int) {
	for id := range m.removedproduct {
		ids = append(ids, id)
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
func (m *StoreMutation) ProductIDs() (ids []int) {
	for id := range m.product {
		ids = append(ids, id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *StoreMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
	m.removedproduct = nil
}

// Where appends a list predicates to the StoreMutation builder.
func (m *StoreMutation) Where(ps ...predicate.Store) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StoreMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StoreMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Store, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StoreMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StoreMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Store).
func (m *StoreMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StoreMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.kor_id != nil {
		fields = append(fields, store.FieldKorID)
	}
	if m.url != nil {
		fields = append(fields, store.FieldURL)
	}
	if m.country != nil {
		fields = append(fields, store.FieldCountry)
	}
	if m.currency != nil {
		fields = append(fields, store.FieldCurrency)
	}
	if m.tax_reduction != nil {
		fields = append(fields, store.FieldTaxReduction)
	}
	if m.tax_reduction_manually != nil {
		fields = append(fields, store.FieldTaxReductionManually)
	}
	if m.intl_shipping_fee != nil {
		fields = append(fields, store.FieldIntlShippingFee)
	}
	if m.intl_free_shipping_min != nil {
		fields = append(fields, store.FieldIntlFreeShippingMin)
	}
	if m.domestic_shipping_fee != nil {
		fields = append(fields, store.FieldDomesticShippingFee)
	}
	if m.domestic_free_shipping_min != nil {
		fields = append(fields, store.FieldDomesticFreeShippingMin)
	}
	if m.shipping_fee_cumulation != nil {
		fields = append(fields, store.FieldShippingFeeCumulation)
	}
	if m.delivery_agency != nil {
		fields = append(fields, store.FieldDeliveryAgency)
	}
	if m.broker_fee != nil {
		fields = append(fields, store.FieldBrokerFee)
	}
	if m.ddp != nil {
		fields = append(fields, store.FieldDdp)
	}
	if m.updated_at != nil {
		fields = append(fields, store.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StoreMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case store.FieldKorID:
		return m.KorID()
	case store.FieldURL:
		return m.URL()
	case store.FieldCountry:
		return m.Country()
	case store.FieldCurrency:
		return m.Currency()
	case store.FieldTaxReduction:
		return m.TaxReduction()
	case store.FieldTaxReductionManually:
		return m.TaxReductionManually()
	case store.FieldIntlShippingFee:
		return m.IntlShippingFee()
	case store.FieldIntlFreeShippingMin:
		return m.IntlFreeShippingMin()
	case store.FieldDomesticShippingFee:
		return m.DomesticShippingFee()
	case store.FieldDomesticFreeShippingMin:
		return m.DomesticFreeShippingMin()
	case store.FieldShippingFeeCumulation:
		return m.ShippingFeeCumulation()
	case store.FieldDeliveryAgency:
		return m.DeliveryAgency()
	case store.FieldBrokerFee:
		return m.BrokerFee()
	case store.FieldDdp:
		return m.Ddp()
	case store.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StoreMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case store.FieldKorID:
		return m.OldKorID(ctx)
	case store.FieldURL:
		return m.OldURL(ctx)
	case store.FieldCountry:
		return m.OldCountry(ctx)
	case store.FieldCurrency:
		return m.OldCurrency(ctx)
	case store.FieldTaxReduction:
		return m.OldTaxReduction(ctx)
	case store.FieldTaxReductionManually:
		return m.OldTaxReductionManually(ctx)
	case store.FieldIntlShippingFee:
		return m.OldIntlShippingFee(ctx)
	case store.FieldIntlFreeShippingMin:
		return m.OldIntlFreeShippingMin(ctx)
	case store.FieldDomesticShippingFee:
		return m.OldDomesticShippingFee(ctx)
	case store.FieldDomesticFreeShippingMin:
		return m.OldDomesticFreeShippingMin(ctx)
	case store.FieldShippingFeeCumulation:
		return m.OldShippingFeeCumulation(ctx)
	case store.FieldDeliveryAgency:
		return m.OldDeliveryAgency(ctx)
	case store.FieldBrokerFee:
		return m.OldBrokerFee(ctx)
	case store.FieldDdp:
		return m.OldDdp(ctx)
	case store.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Store field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoreMutation) SetField(name string, value ent.Value) error {
	switch name {
	case store.FieldKorID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKorID(v)
		return nil
	case store.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case store.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case store.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case store.FieldTaxReduction:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxReduction(v)
		return nil
	case store.FieldTaxReductionManually:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxReductionManually(v)
		return nil
	case store.FieldIntlShippingFee:
		v, ok := value.(*schema.ShippingFee)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntlShippingFee(v)
		return nil
	case store.FieldIntlFreeShippingMin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntlFreeShippingMin(v)
		return nil
	case store.FieldDomesticShippingFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomesticShippingFee(v)
		return nil
	case store.FieldDomesticFreeShippingMin:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomesticFreeShippingMin(v)
		return nil
	case store.FieldShippingFeeCumulation:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingFeeCumulation(v)
		return nil
	case store.FieldDeliveryAgency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryAgency(v)
		return nil
	case store.FieldBrokerFee:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrokerFee(v)
		return nil
	case store.FieldDdp:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDdp(v)
		return nil
	case store.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Store field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StoreMutation) AddedFields() []string {
	var fields []string
	if m.addtax_reduction != nil {
		fields = append(fields, store.FieldTaxReduction)
	}
	if m.addintl_free_shipping_min != nil {
		fields = append(fields, store.FieldIntlFreeShippingMin)
	}
	if m.adddomestic_shipping_fee != nil {
		fields = append(fields, store.FieldDomesticShippingFee)
	}
	if m.adddomestic_free_shipping_min != nil {
		fields = append(fields, store.FieldDomesticFreeShippingMin)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StoreMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case store.FieldTaxReduction:
		return m.AddedTaxReduction()
	case store.FieldIntlFreeShippingMin:
		return m.AddedIntlFreeShippingMin()
	case store.FieldDomesticShippingFee:
		return m.AddedDomesticShippingFee()
	case store.FieldDomesticFreeShippingMin:
		return m.AddedDomesticFreeShippingMin()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoreMutation) AddField(name string, value ent.Value) error {
	switch name {
	case store.FieldTaxReduction:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTaxReduction(v)
		return nil
	case store.FieldIntlFreeShippingMin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIntlFreeShippingMin(v)
		return nil
	case store.FieldDomesticShippingFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDomesticShippingFee(v)
		return nil
	case store.FieldDomesticFreeShippingMin:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDomesticFreeShippingMin(v)
		return nil
	}
	return fmt.Errorf("unknown Store numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StoreMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StoreMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StoreMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Store nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StoreMutation) ResetField(name string) error {
	switch name {
	case store.FieldKorID:
		m.ResetKorID()
		return nil
	case store.FieldURL:
		m.ResetURL()
		return nil
	case store.FieldCountry:
		m.ResetCountry()
		return nil
	case store.FieldCurrency:
		m.ResetCurrency()
		return nil
	case store.FieldTaxReduction:
		m.ResetTaxReduction()
		return nil
	case store.FieldTaxReductionManually:
		m.ResetTaxReductionManually()
		return nil
	case store.FieldIntlShippingFee:
		m.ResetIntlShippingFee()
		return nil
	case store.FieldIntlFreeShippingMin:
		m.ResetIntlFreeShippingMin()
		return nil
	case store.FieldDomesticShippingFee:
		m.ResetDomesticShippingFee()
		return nil
	case store.FieldDomesticFreeShippingMin:
		m.ResetDomesticFreeShippingMin()
		return nil
	case store.FieldShippingFeeCumulation:
		m.ResetShippingFeeCumulation()
		return nil
	case store.FieldDeliveryAgency:
		m.ResetDeliveryAgency()
		return nil
	case store.FieldBrokerFee:
		m.ResetBrokerFee()
		return nil
	case store.FieldDdp:
		m.ResetDdp()
		return nil
	case store.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Store field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StoreMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.product != nil {
		edges = append(edges, store.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StoreMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case store.EdgeProduct:
		ids := make([]ent.Value, 0, len(m.product))
		for id := range m.product {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StoreMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedproduct != nil {
		edges = append(edges, store.EdgeProduct)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StoreMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case store.EdgeProduct:
		ids := make([]ent.Value, 0, len(m.removedproduct))
		for id := range m.removedproduct {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StoreMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproduct {
		edges = append(edges, store.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StoreMutation) EdgeCleared(name string) bool {
	switch name {
	case store.EdgeProduct:
		return m.clearedproduct
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StoreMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Store unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StoreMutation) ResetEdge(name string) error {
	switch name {
	case store.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown Store edge %s", name)
}
