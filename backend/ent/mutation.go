// Code generated by ent, DO NOT EDIT.

package ent

import (
	"backend/ent/deliveryagency"
	"backend/ent/predicate"
	"backend/ent/product"
	"backend/ent/schema"
	"backend/ent/store"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDeliveryAgency = "DeliveryAgency"
	TypeProduct        = "Product"
	TypeStore          = "Store"
)

// DeliveryAgencyMutation represents an operation that mutates the DeliveryAgency nodes in the graph.
type DeliveryAgencyMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	country                *string
	_VAT_reduction_rate    *float64
	add_VAT_reduction_rate *float64
	shipping_fee           **schema.AgencyShippingFee
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	products               map[int]struct{}
	removedproducts        map[int]struct{}
	clearedproducts        bool
	done                   bool
	oldValue               func(context.Context) (*DeliveryAgency, error)
	predicates             []predicate.DeliveryAgency
}

var _ ent.Mutation = (*DeliveryAgencyMutation)(nil)

// deliveryagencyOption allows management of the mutation configuration using functional options.
type deliveryagencyOption func(*DeliveryAgencyMutation)

// newDeliveryAgencyMutation creates new mutation for the DeliveryAgency entity.
func newDeliveryAgencyMutation(c config, op Op, opts ...deliveryagencyOption) *DeliveryAgencyMutation {
	m := &DeliveryAgencyMutation{
		config:        c,
		op:            op,
		typ:           TypeDeliveryAgency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeliveryAgencyID sets the ID field of the mutation.
func withDeliveryAgencyID(id int) deliveryagencyOption {
	return func(m *DeliveryAgencyMutation) {
		var (
			err   error
			once  sync.Once
			value *DeliveryAgency
		)
		m.oldValue = func(ctx context.Context) (*DeliveryAgency, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeliveryAgency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeliveryAgency sets the old DeliveryAgency of the mutation.
func withDeliveryAgency(node *DeliveryAgency) deliveryagencyOption {
	return func(m *DeliveryAgencyMutation) {
		m.oldValue = func(context.Context) (*DeliveryAgency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeliveryAgencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeliveryAgencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeliveryAgencyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeliveryAgencyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeliveryAgency.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCountry sets the "country" field.
func (m *DeliveryAgencyMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *DeliveryAgencyMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the DeliveryAgency entity.
// If the DeliveryAgency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryAgencyMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *DeliveryAgencyMutation) ResetCountry() {
	m.country = nil
}

// SetVATReductionRate sets the "VAT_reduction_rate" field.
func (m *DeliveryAgencyMutation) SetVATReductionRate(f float64) {
	m._VAT_reduction_rate = &f
	m.add_VAT_reduction_rate = nil
}

// VATReductionRate returns the value of the "VAT_reduction_rate" field in the mutation.
func (m *DeliveryAgencyMutation) VATReductionRate() (r float64, exists bool) {
	v := m._VAT_reduction_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldVATReductionRate returns the old "VAT_reduction_rate" field's value of the DeliveryAgency entity.
// If the DeliveryAgency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryAgencyMutation) OldVATReductionRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVATReductionRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVATReductionRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVATReductionRate: %w", err)
	}
	return oldValue.VATReductionRate, nil
}

// AddVATReductionRate adds f to the "VAT_reduction_rate" field.
func (m *DeliveryAgencyMutation) AddVATReductionRate(f float64) {
	if m.add_VAT_reduction_rate != nil {
		*m.add_VAT_reduction_rate += f
	} else {
		m.add_VAT_reduction_rate = &f
	}
}

// AddedVATReductionRate returns the value that was added to the "VAT_reduction_rate" field in this mutation.
func (m *DeliveryAgencyMutation) AddedVATReductionRate() (r float64, exists bool) {
	v := m.add_VAT_reduction_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetVATReductionRate resets all changes to the "VAT_reduction_rate" field.
func (m *DeliveryAgencyMutation) ResetVATReductionRate() {
	m._VAT_reduction_rate = nil
	m.add_VAT_reduction_rate = nil
}

// SetShippingFee sets the "shipping_fee" field.
func (m *DeliveryAgencyMutation) SetShippingFee(ssf *schema.AgencyShippingFee) {
	m.shipping_fee = &ssf
}

// ShippingFee returns the value of the "shipping_fee" field in the mutation.
func (m *DeliveryAgencyMutation) ShippingFee() (r *schema.AgencyShippingFee, exists bool) {
	v := m.shipping_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingFee returns the old "shipping_fee" field's value of the DeliveryAgency entity.
// If the DeliveryAgency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryAgencyMutation) OldShippingFee(ctx context.Context) (v *schema.AgencyShippingFee, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShippingFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShippingFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingFee: %w", err)
	}
	return oldValue.ShippingFee, nil
}

// ResetShippingFee resets all changes to the "shipping_fee" field.
func (m *DeliveryAgencyMutation) ResetShippingFee() {
	m.shipping_fee = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeliveryAgencyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeliveryAgencyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeliveryAgency entity.
// If the DeliveryAgency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryAgencyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeliveryAgencyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *DeliveryAgencyMutation) AddProductIDs(ids ...int) {
	if m.products == nil {
		m.products = make(map[int]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *DeliveryAgencyMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *DeliveryAgencyMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *DeliveryAgencyMutation) RemoveProductIDs(ids ...int) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *DeliveryAgencyMutation) RemovedProductsIDs() (ids []int) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *DeliveryAgencyMutation) ProductsIDs() (ids []int) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *DeliveryAgencyMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// Where appends a list predicates to the DeliveryAgencyMutation builder.
func (m *DeliveryAgencyMutation) Where(ps ...predicate.DeliveryAgency) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeliveryAgencyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeliveryAgencyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeliveryAgency, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeliveryAgencyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeliveryAgencyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeliveryAgency).
func (m *DeliveryAgencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeliveryAgencyMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.country != nil {
		fields = append(fields, deliveryagency.FieldCountry)
	}
	if m._VAT_reduction_rate != nil {
		fields = append(fields, deliveryagency.FieldVATReductionRate)
	}
	if m.shipping_fee != nil {
		fields = append(fields, deliveryagency.FieldShippingFee)
	}
	if m.updated_at != nil {
		fields = append(fields, deliveryagency.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeliveryAgencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deliveryagency.FieldCountry:
		return m.Country()
	case deliveryagency.FieldVATReductionRate:
		return m.VATReductionRate()
	case deliveryagency.FieldShippingFee:
		return m.ShippingFee()
	case deliveryagency.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeliveryAgencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deliveryagency.FieldCountry:
		return m.OldCountry(ctx)
	case deliveryagency.FieldVATReductionRate:
		return m.OldVATReductionRate(ctx)
	case deliveryagency.FieldShippingFee:
		return m.OldShippingFee(ctx)
	case deliveryagency.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown DeliveryAgency field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliveryAgencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deliveryagency.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case deliveryagency.FieldVATReductionRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVATReductionRate(v)
		return nil
	case deliveryagency.FieldShippingFee:
		v, ok := value.(*schema.AgencyShippingFee)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingFee(v)
		return nil
	case deliveryagency.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown DeliveryAgency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeliveryAgencyMutation) AddedFields() []string {
	var fields []string
	if m.add_VAT_reduction_rate != nil {
		fields = append(fields, deliveryagency.FieldVATReductionRate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeliveryAgencyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case deliveryagency.FieldVATReductionRate:
		return m.AddedVATReductionRate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliveryAgencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case deliveryagency.FieldVATReductionRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVATReductionRate(v)
		return nil
	}
	return fmt.Errorf("unknown DeliveryAgency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeliveryAgencyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeliveryAgencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeliveryAgencyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DeliveryAgency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeliveryAgencyMutation) ResetField(name string) error {
	switch name {
	case deliveryagency.FieldCountry:
		m.ResetCountry()
		return nil
	case deliveryagency.FieldVATReductionRate:
		m.ResetVATReductionRate()
		return nil
	case deliveryagency.FieldShippingFee:
		m.ResetShippingFee()
		return nil
	case deliveryagency.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown DeliveryAgency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeliveryAgencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.products != nil {
		edges = append(edges, deliveryagency.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeliveryAgencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deliveryagency.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeliveryAgencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedproducts != nil {
		edges = append(edges, deliveryagency.EdgeProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeliveryAgencyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deliveryagency.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeliveryAgencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproducts {
		edges = append(edges, deliveryagency.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeliveryAgencyMutation) EdgeCleared(name string) bool {
	switch name {
	case deliveryagency.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeliveryAgencyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DeliveryAgency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeliveryAgencyMutation) ResetEdge(name string) error {
	switch name {
	case deliveryagency.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown DeliveryAgency edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op               Op
	typ              string
	id               *int
	store_id         *int
	addstore_id      *int
	brand            *string
	product_name     *string
	price            *int
	addprice         *int
	kor_brand        *string
	kor_product_name *string
	product_id       *string
	gender           *product.Gender
	color            *string
	category         *string
	category_spec    *string
	sold_out         *bool
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Product, error)
	predicates       []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id int) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Product.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStoreID sets the "store_id" field.
func (m *ProductMutation) SetStoreID(i int) {
	m.store_id = &i
	m.addstore_id = nil
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *ProductMutation) StoreID() (r int, exists bool) {
	v := m.store_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldStoreID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// AddStoreID adds i to the "store_id" field.
func (m *ProductMutation) AddStoreID(i int) {
	if m.addstore_id != nil {
		*m.addstore_id += i
	} else {
		m.addstore_id = &i
	}
}

// AddedStoreID returns the value that was added to the "store_id" field in this mutation.
func (m *ProductMutation) AddedStoreID() (r int, exists bool) {
	v := m.addstore_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *ProductMutation) ResetStoreID() {
	m.store_id = nil
	m.addstore_id = nil
}

// SetBrand sets the "brand" field.
func (m *ProductMutation) SetBrand(s string) {
	m.brand = &s
}

// Brand returns the value of the "brand" field in the mutation.
func (m *ProductMutation) Brand() (r string, exists bool) {
	v := m.brand
	if v == nil {
		return
	}
	return *v, true
}

// OldBrand returns the old "brand" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldBrand(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrand: %w", err)
	}
	return oldValue.Brand, nil
}

// ResetBrand resets all changes to the "brand" field.
func (m *ProductMutation) ResetBrand() {
	m.brand = nil
}

// SetProductName sets the "product_name" field.
func (m *ProductMutation) SetProductName(s string) {
	m.product_name = &s
}

// ProductName returns the value of the "product_name" field in the mutation.
func (m *ProductMutation) ProductName() (r string, exists bool) {
	v := m.product_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProductName returns the old "product_name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldProductName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductName: %w", err)
	}
	return oldValue.ProductName, nil
}

// ResetProductName resets all changes to the "product_name" field.
func (m *ProductMutation) ResetProductName() {
	m.product_name = nil
}

// SetPrice sets the "price" field.
func (m *ProductMutation) SetPrice(i int) {
	m.price = &i
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *ProductMutation) Price() (r int, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds i to the "price" field.
func (m *ProductMutation) AddPrice(i int) {
	if m.addprice != nil {
		*m.addprice += i
	} else {
		m.addprice = &i
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *ProductMutation) AddedPrice() (r int, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *ProductMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetKorBrand sets the "kor_brand" field.
func (m *ProductMutation) SetKorBrand(s string) {
	m.kor_brand = &s
}

// KorBrand returns the value of the "kor_brand" field in the mutation.
func (m *ProductMutation) KorBrand() (r string, exists bool) {
	v := m.kor_brand
	if v == nil {
		return
	}
	return *v, true
}

// OldKorBrand returns the old "kor_brand" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldKorBrand(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKorBrand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKorBrand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKorBrand: %w", err)
	}
	return oldValue.KorBrand, nil
}

// ClearKorBrand clears the value of the "kor_brand" field.
func (m *ProductMutation) ClearKorBrand() {
	m.kor_brand = nil
	m.clearedFields[product.FieldKorBrand] = struct{}{}
}

// KorBrandCleared returns if the "kor_brand" field was cleared in this mutation.
func (m *ProductMutation) KorBrandCleared() bool {
	_, ok := m.clearedFields[product.FieldKorBrand]
	return ok
}

// ResetKorBrand resets all changes to the "kor_brand" field.
func (m *ProductMutation) ResetKorBrand() {
	m.kor_brand = nil
	delete(m.clearedFields, product.FieldKorBrand)
}

// SetKorProductName sets the "kor_product_name" field.
func (m *ProductMutation) SetKorProductName(s string) {
	m.kor_product_name = &s
}

// KorProductName returns the value of the "kor_product_name" field in the mutation.
func (m *ProductMutation) KorProductName() (r string, exists bool) {
	v := m.kor_product_name
	if v == nil {
		return
	}
	return *v, true
}

// OldKorProductName returns the old "kor_product_name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldKorProductName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKorProductName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKorProductName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKorProductName: %w", err)
	}
	return oldValue.KorProductName, nil
}

// ClearKorProductName clears the value of the "kor_product_name" field.
func (m *ProductMutation) ClearKorProductName() {
	m.kor_product_name = nil
	m.clearedFields[product.FieldKorProductName] = struct{}{}
}

// KorProductNameCleared returns if the "kor_product_name" field was cleared in this mutation.
func (m *ProductMutation) KorProductNameCleared() bool {
	_, ok := m.clearedFields[product.FieldKorProductName]
	return ok
}

// ResetKorProductName resets all changes to the "kor_product_name" field.
func (m *ProductMutation) ResetKorProductName() {
	m.kor_product_name = nil
	delete(m.clearedFields, product.FieldKorProductName)
}

// SetProductID sets the "product_id" field.
func (m *ProductMutation) SetProductID(s string) {
	m.product_id = &s
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *ProductMutation) ProductID() (r string, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldProductID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ClearProductID clears the value of the "product_id" field.
func (m *ProductMutation) ClearProductID() {
	m.product_id = nil
	m.clearedFields[product.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *ProductMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[product.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *ProductMutation) ResetProductID() {
	m.product_id = nil
	delete(m.clearedFields, product.FieldProductID)
}

// SetGender sets the "gender" field.
func (m *ProductMutation) SetGender(pr product.Gender) {
	m.gender = &pr
}

// Gender returns the value of the "gender" field in the mutation.
func (m *ProductMutation) Gender() (r product.Gender, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldGender(ctx context.Context) (v product.Gender, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ClearGender clears the value of the "gender" field.
func (m *ProductMutation) ClearGender() {
	m.gender = nil
	m.clearedFields[product.FieldGender] = struct{}{}
}

// GenderCleared returns if the "gender" field was cleared in this mutation.
func (m *ProductMutation) GenderCleared() bool {
	_, ok := m.clearedFields[product.FieldGender]
	return ok
}

// ResetGender resets all changes to the "gender" field.
func (m *ProductMutation) ResetGender() {
	m.gender = nil
	delete(m.clearedFields, product.FieldGender)
}

// SetColor sets the "color" field.
func (m *ProductMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *ProductMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *ProductMutation) ClearColor() {
	m.color = nil
	m.clearedFields[product.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *ProductMutation) ColorCleared() bool {
	_, ok := m.clearedFields[product.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *ProductMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, product.FieldColor)
}

// SetCategory sets the "category" field.
func (m *ProductMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ProductMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *ProductMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[product.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *ProductMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[product.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *ProductMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, product.FieldCategory)
}

// SetCategorySpec sets the "category_spec" field.
func (m *ProductMutation) SetCategorySpec(s string) {
	m.category_spec = &s
}

// CategorySpec returns the value of the "category_spec" field in the mutation.
func (m *ProductMutation) CategorySpec() (r string, exists bool) {
	v := m.category_spec
	if v == nil {
		return
	}
	return *v, true
}

// OldCategorySpec returns the old "category_spec" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCategorySpec(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategorySpec is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategorySpec requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategorySpec: %w", err)
	}
	return oldValue.CategorySpec, nil
}

// ClearCategorySpec clears the value of the "category_spec" field.
func (m *ProductMutation) ClearCategorySpec() {
	m.category_spec = nil
	m.clearedFields[product.FieldCategorySpec] = struct{}{}
}

// CategorySpecCleared returns if the "category_spec" field was cleared in this mutation.
func (m *ProductMutation) CategorySpecCleared() bool {
	_, ok := m.clearedFields[product.FieldCategorySpec]
	return ok
}

// ResetCategorySpec resets all changes to the "category_spec" field.
func (m *ProductMutation) ResetCategorySpec() {
	m.category_spec = nil
	delete(m.clearedFields, product.FieldCategorySpec)
}

// SetSoldOut sets the "sold_out" field.
func (m *ProductMutation) SetSoldOut(b bool) {
	m.sold_out = &b
}

// SoldOut returns the value of the "sold_out" field in the mutation.
func (m *ProductMutation) SoldOut() (r bool, exists bool) {
	v := m.sold_out
	if v == nil {
		return
	}
	return *v, true
}

// OldSoldOut returns the old "sold_out" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSoldOut(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSoldOut is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSoldOut requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSoldOut: %w", err)
	}
	return oldValue.SoldOut, nil
}

// ResetSoldOut resets all changes to the "sold_out" field.
func (m *ProductMutation) ResetSoldOut() {
	m.sold_out = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Product, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.store_id != nil {
		fields = append(fields, product.FieldStoreID)
	}
	if m.brand != nil {
		fields = append(fields, product.FieldBrand)
	}
	if m.product_name != nil {
		fields = append(fields, product.FieldProductName)
	}
	if m.price != nil {
		fields = append(fields, product.FieldPrice)
	}
	if m.kor_brand != nil {
		fields = append(fields, product.FieldKorBrand)
	}
	if m.kor_product_name != nil {
		fields = append(fields, product.FieldKorProductName)
	}
	if m.product_id != nil {
		fields = append(fields, product.FieldProductID)
	}
	if m.gender != nil {
		fields = append(fields, product.FieldGender)
	}
	if m.color != nil {
		fields = append(fields, product.FieldColor)
	}
	if m.category != nil {
		fields = append(fields, product.FieldCategory)
	}
	if m.category_spec != nil {
		fields = append(fields, product.FieldCategorySpec)
	}
	if m.sold_out != nil {
		fields = append(fields, product.FieldSoldOut)
	}
	if m.updated_at != nil {
		fields = append(fields, product.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldStoreID:
		return m.StoreID()
	case product.FieldBrand:
		return m.Brand()
	case product.FieldProductName:
		return m.ProductName()
	case product.FieldPrice:
		return m.Price()
	case product.FieldKorBrand:
		return m.KorBrand()
	case product.FieldKorProductName:
		return m.KorProductName()
	case product.FieldProductID:
		return m.ProductID()
	case product.FieldGender:
		return m.Gender()
	case product.FieldColor:
		return m.Color()
	case product.FieldCategory:
		return m.Category()
	case product.FieldCategorySpec:
		return m.CategorySpec()
	case product.FieldSoldOut:
		return m.SoldOut()
	case product.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldStoreID:
		return m.OldStoreID(ctx)
	case product.FieldBrand:
		return m.OldBrand(ctx)
	case product.FieldProductName:
		return m.OldProductName(ctx)
	case product.FieldPrice:
		return m.OldPrice(ctx)
	case product.FieldKorBrand:
		return m.OldKorBrand(ctx)
	case product.FieldKorProductName:
		return m.OldKorProductName(ctx)
	case product.FieldProductID:
		return m.OldProductID(ctx)
	case product.FieldGender:
		return m.OldGender(ctx)
	case product.FieldColor:
		return m.OldColor(ctx)
	case product.FieldCategory:
		return m.OldCategory(ctx)
	case product.FieldCategorySpec:
		return m.OldCategorySpec(ctx)
	case product.FieldSoldOut:
		return m.OldSoldOut(ctx)
	case product.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case product.FieldBrand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrand(v)
		return nil
	case product.FieldProductName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductName(v)
		return nil
	case product.FieldPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case product.FieldKorBrand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKorBrand(v)
		return nil
	case product.FieldKorProductName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKorProductName(v)
		return nil
	case product.FieldProductID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case product.FieldGender:
		v, ok := value.(product.Gender)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case product.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case product.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case product.FieldCategorySpec:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategorySpec(v)
		return nil
	case product.FieldSoldOut:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSoldOut(v)
		return nil
	case product.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	if m.addstore_id != nil {
		fields = append(fields, product.FieldStoreID)
	}
	if m.addprice != nil {
		fields = append(fields, product.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case product.FieldStoreID:
		return m.AddedStoreID()
	case product.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case product.FieldStoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStoreID(v)
		return nil
	case product.FieldPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(product.FieldKorBrand) {
		fields = append(fields, product.FieldKorBrand)
	}
	if m.FieldCleared(product.FieldKorProductName) {
		fields = append(fields, product.FieldKorProductName)
	}
	if m.FieldCleared(product.FieldProductID) {
		fields = append(fields, product.FieldProductID)
	}
	if m.FieldCleared(product.FieldGender) {
		fields = append(fields, product.FieldGender)
	}
	if m.FieldCleared(product.FieldColor) {
		fields = append(fields, product.FieldColor)
	}
	if m.FieldCleared(product.FieldCategory) {
		fields = append(fields, product.FieldCategory)
	}
	if m.FieldCleared(product.FieldCategorySpec) {
		fields = append(fields, product.FieldCategorySpec)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	switch name {
	case product.FieldKorBrand:
		m.ClearKorBrand()
		return nil
	case product.FieldKorProductName:
		m.ClearKorProductName()
		return nil
	case product.FieldProductID:
		m.ClearProductID()
		return nil
	case product.FieldGender:
		m.ClearGender()
		return nil
	case product.FieldColor:
		m.ClearColor()
		return nil
	case product.FieldCategory:
		m.ClearCategory()
		return nil
	case product.FieldCategorySpec:
		m.ClearCategorySpec()
		return nil
	}
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldStoreID:
		m.ResetStoreID()
		return nil
	case product.FieldBrand:
		m.ResetBrand()
		return nil
	case product.FieldProductName:
		m.ResetProductName()
		return nil
	case product.FieldPrice:
		m.ResetPrice()
		return nil
	case product.FieldKorBrand:
		m.ResetKorBrand()
		return nil
	case product.FieldKorProductName:
		m.ResetKorProductName()
		return nil
	case product.FieldProductID:
		m.ResetProductID()
		return nil
	case product.FieldGender:
		m.ResetGender()
		return nil
	case product.FieldColor:
		m.ResetColor()
		return nil
	case product.FieldCategory:
		m.ResetCategory()
		return nil
	case product.FieldCategorySpec:
		m.ResetCategorySpec()
		return nil
	case product.FieldSoldOut:
		m.ResetSoldOut()
		return nil
	case product.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Product edge %s", name)
}

// StoreMutation represents an operation that mutates the Store nodes in the graph.
type StoreMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	store_name                      *string
	url                             *string
	country                         *string
	currency                        *string
	tax_reduction                   *float64
	addtax_reduction                *float64
	intl_shipping_fee               **schema.ShippingFee
	intl_free_shipping_price        *int
	addintl_free_shipping_price     *int
	domestic_shipping_fee           *float64
	adddomestic_shipping_fee        *float64
	domestic_free_shipping_price    *float64
	adddomestic_free_shipping_price *float64
	delivery_agency                 *string
	broker_fee                      *bool
	ddp                             *bool
	updated_at                      *time.Time
	clearedFields                   map[string]struct{}
	products                        map[int]struct{}
	removedproducts                 map[int]struct{}
	clearedproducts                 bool
	done                            bool
	oldValue                        func(context.Context) (*Store, error)
	predicates                      []predicate.Store
}

var _ ent.Mutation = (*StoreMutation)(nil)

// storeOption allows management of the mutation configuration using functional options.
type storeOption func(*StoreMutation)

// newStoreMutation creates new mutation for the Store entity.
func newStoreMutation(c config, op Op, opts ...storeOption) *StoreMutation {
	m := &StoreMutation{
		config:        c,
		op:            op,
		typ:           TypeStore,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStoreID sets the ID field of the mutation.
func withStoreID(id int) storeOption {
	return func(m *StoreMutation) {
		var (
			err   error
			once  sync.Once
			value *Store
		)
		m.oldValue = func(ctx context.Context) (*Store, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Store.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStore sets the old Store of the mutation.
func withStore(node *Store) storeOption {
	return func(m *StoreMutation) {
		m.oldValue = func(context.Context) (*Store, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StoreMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StoreMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StoreMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StoreMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Store.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStoreName sets the "store_name" field.
func (m *StoreMutation) SetStoreName(s string) {
	m.store_name = &s
}

// StoreName returns the value of the "store_name" field in the mutation.
func (m *StoreMutation) StoreName() (r string, exists bool) {
	v := m.store_name
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreName returns the old "store_name" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldStoreName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreName: %w", err)
	}
	return oldValue.StoreName, nil
}

// ResetStoreName resets all changes to the "store_name" field.
func (m *StoreMutation) ResetStoreName() {
	m.store_name = nil
}

// SetURL sets the "url" field.
func (m *StoreMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *StoreMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *StoreMutation) ResetURL() {
	m.url = nil
}

// SetCountry sets the "country" field.
func (m *StoreMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *StoreMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *StoreMutation) ResetCountry() {
	m.country = nil
}

// SetCurrency sets the "currency" field.
func (m *StoreMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *StoreMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *StoreMutation) ResetCurrency() {
	m.currency = nil
}

// SetTaxReduction sets the "tax_reduction" field.
func (m *StoreMutation) SetTaxReduction(f float64) {
	m.tax_reduction = &f
	m.addtax_reduction = nil
}

// TaxReduction returns the value of the "tax_reduction" field in the mutation.
func (m *StoreMutation) TaxReduction() (r float64, exists bool) {
	v := m.tax_reduction
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxReduction returns the old "tax_reduction" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldTaxReduction(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxReduction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxReduction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxReduction: %w", err)
	}
	return oldValue.TaxReduction, nil
}

// AddTaxReduction adds f to the "tax_reduction" field.
func (m *StoreMutation) AddTaxReduction(f float64) {
	if m.addtax_reduction != nil {
		*m.addtax_reduction += f
	} else {
		m.addtax_reduction = &f
	}
}

// AddedTaxReduction returns the value that was added to the "tax_reduction" field in this mutation.
func (m *StoreMutation) AddedTaxReduction() (r float64, exists bool) {
	v := m.addtax_reduction
	if v == nil {
		return
	}
	return *v, true
}

// ResetTaxReduction resets all changes to the "tax_reduction" field.
func (m *StoreMutation) ResetTaxReduction() {
	m.tax_reduction = nil
	m.addtax_reduction = nil
}

// SetIntlShippingFee sets the "intl_shipping_fee" field.
func (m *StoreMutation) SetIntlShippingFee(sf *schema.ShippingFee) {
	m.intl_shipping_fee = &sf
}

// IntlShippingFee returns the value of the "intl_shipping_fee" field in the mutation.
func (m *StoreMutation) IntlShippingFee() (r *schema.ShippingFee, exists bool) {
	v := m.intl_shipping_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldIntlShippingFee returns the old "intl_shipping_fee" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldIntlShippingFee(ctx context.Context) (v *schema.ShippingFee, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntlShippingFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntlShippingFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntlShippingFee: %w", err)
	}
	return oldValue.IntlShippingFee, nil
}

// ResetIntlShippingFee resets all changes to the "intl_shipping_fee" field.
func (m *StoreMutation) ResetIntlShippingFee() {
	m.intl_shipping_fee = nil
}

// SetIntlFreeShippingPrice sets the "intl_free_shipping_price" field.
func (m *StoreMutation) SetIntlFreeShippingPrice(i int) {
	m.intl_free_shipping_price = &i
	m.addintl_free_shipping_price = nil
}

// IntlFreeShippingPrice returns the value of the "intl_free_shipping_price" field in the mutation.
func (m *StoreMutation) IntlFreeShippingPrice() (r int, exists bool) {
	v := m.intl_free_shipping_price
	if v == nil {
		return
	}
	return *v, true
}

// OldIntlFreeShippingPrice returns the old "intl_free_shipping_price" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldIntlFreeShippingPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntlFreeShippingPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntlFreeShippingPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntlFreeShippingPrice: %w", err)
	}
	return oldValue.IntlFreeShippingPrice, nil
}

// AddIntlFreeShippingPrice adds i to the "intl_free_shipping_price" field.
func (m *StoreMutation) AddIntlFreeShippingPrice(i int) {
	if m.addintl_free_shipping_price != nil {
		*m.addintl_free_shipping_price += i
	} else {
		m.addintl_free_shipping_price = &i
	}
}

// AddedIntlFreeShippingPrice returns the value that was added to the "intl_free_shipping_price" field in this mutation.
func (m *StoreMutation) AddedIntlFreeShippingPrice() (r int, exists bool) {
	v := m.addintl_free_shipping_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetIntlFreeShippingPrice resets all changes to the "intl_free_shipping_price" field.
func (m *StoreMutation) ResetIntlFreeShippingPrice() {
	m.intl_free_shipping_price = nil
	m.addintl_free_shipping_price = nil
}

// SetDomesticShippingFee sets the "domestic_shipping_fee" field.
func (m *StoreMutation) SetDomesticShippingFee(f float64) {
	m.domestic_shipping_fee = &f
	m.adddomestic_shipping_fee = nil
}

// DomesticShippingFee returns the value of the "domestic_shipping_fee" field in the mutation.
func (m *StoreMutation) DomesticShippingFee() (r float64, exists bool) {
	v := m.domestic_shipping_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldDomesticShippingFee returns the old "domestic_shipping_fee" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldDomesticShippingFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomesticShippingFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomesticShippingFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomesticShippingFee: %w", err)
	}
	return oldValue.DomesticShippingFee, nil
}

// AddDomesticShippingFee adds f to the "domestic_shipping_fee" field.
func (m *StoreMutation) AddDomesticShippingFee(f float64) {
	if m.adddomestic_shipping_fee != nil {
		*m.adddomestic_shipping_fee += f
	} else {
		m.adddomestic_shipping_fee = &f
	}
}

// AddedDomesticShippingFee returns the value that was added to the "domestic_shipping_fee" field in this mutation.
func (m *StoreMutation) AddedDomesticShippingFee() (r float64, exists bool) {
	v := m.adddomestic_shipping_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetDomesticShippingFee resets all changes to the "domestic_shipping_fee" field.
func (m *StoreMutation) ResetDomesticShippingFee() {
	m.domestic_shipping_fee = nil
	m.adddomestic_shipping_fee = nil
}

// SetDomesticFreeShippingPrice sets the "domestic_free_shipping_price" field.
func (m *StoreMutation) SetDomesticFreeShippingPrice(f float64) {
	m.domestic_free_shipping_price = &f
	m.adddomestic_free_shipping_price = nil
}

// DomesticFreeShippingPrice returns the value of the "domestic_free_shipping_price" field in the mutation.
func (m *StoreMutation) DomesticFreeShippingPrice() (r float64, exists bool) {
	v := m.domestic_free_shipping_price
	if v == nil {
		return
	}
	return *v, true
}

// OldDomesticFreeShippingPrice returns the old "domestic_free_shipping_price" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldDomesticFreeShippingPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomesticFreeShippingPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomesticFreeShippingPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomesticFreeShippingPrice: %w", err)
	}
	return oldValue.DomesticFreeShippingPrice, nil
}

// AddDomesticFreeShippingPrice adds f to the "domestic_free_shipping_price" field.
func (m *StoreMutation) AddDomesticFreeShippingPrice(f float64) {
	if m.adddomestic_free_shipping_price != nil {
		*m.adddomestic_free_shipping_price += f
	} else {
		m.adddomestic_free_shipping_price = &f
	}
}

// AddedDomesticFreeShippingPrice returns the value that was added to the "domestic_free_shipping_price" field in this mutation.
func (m *StoreMutation) AddedDomesticFreeShippingPrice() (r float64, exists bool) {
	v := m.adddomestic_free_shipping_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetDomesticFreeShippingPrice resets all changes to the "domestic_free_shipping_price" field.
func (m *StoreMutation) ResetDomesticFreeShippingPrice() {
	m.domestic_free_shipping_price = nil
	m.adddomestic_free_shipping_price = nil
}

// SetDeliveryAgency sets the "delivery_agency" field.
func (m *StoreMutation) SetDeliveryAgency(s string) {
	m.delivery_agency = &s
}

// DeliveryAgency returns the value of the "delivery_agency" field in the mutation.
func (m *StoreMutation) DeliveryAgency() (r string, exists bool) {
	v := m.delivery_agency
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryAgency returns the old "delivery_agency" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldDeliveryAgency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryAgency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryAgency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryAgency: %w", err)
	}
	return oldValue.DeliveryAgency, nil
}

// ResetDeliveryAgency resets all changes to the "delivery_agency" field.
func (m *StoreMutation) ResetDeliveryAgency() {
	m.delivery_agency = nil
}

// SetBrokerFee sets the "broker_fee" field.
func (m *StoreMutation) SetBrokerFee(b bool) {
	m.broker_fee = &b
}

// BrokerFee returns the value of the "broker_fee" field in the mutation.
func (m *StoreMutation) BrokerFee() (r bool, exists bool) {
	v := m.broker_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldBrokerFee returns the old "broker_fee" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldBrokerFee(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrokerFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrokerFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrokerFee: %w", err)
	}
	return oldValue.BrokerFee, nil
}

// ResetBrokerFee resets all changes to the "broker_fee" field.
func (m *StoreMutation) ResetBrokerFee() {
	m.broker_fee = nil
}

// SetDdp sets the "ddp" field.
func (m *StoreMutation) SetDdp(b bool) {
	m.ddp = &b
}

// Ddp returns the value of the "ddp" field in the mutation.
func (m *StoreMutation) Ddp() (r bool, exists bool) {
	v := m.ddp
	if v == nil {
		return
	}
	return *v, true
}

// OldDdp returns the old "ddp" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldDdp(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDdp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDdp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDdp: %w", err)
	}
	return oldValue.Ddp, nil
}

// ResetDdp resets all changes to the "ddp" field.
func (m *StoreMutation) ResetDdp() {
	m.ddp = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StoreMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StoreMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StoreMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *StoreMutation) AddProductIDs(ids ...int) {
	if m.products == nil {
		m.products = make(map[int]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *StoreMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *StoreMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *StoreMutation) RemoveProductIDs(ids ...int) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *StoreMutation) RemovedProductsIDs() (ids []int) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *StoreMutation) ProductsIDs() (ids []int) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *StoreMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// Where appends a list predicates to the StoreMutation builder.
func (m *StoreMutation) Where(ps ...predicate.Store) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StoreMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StoreMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Store, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StoreMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StoreMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Store).
func (m *StoreMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StoreMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.store_name != nil {
		fields = append(fields, store.FieldStoreName)
	}
	if m.url != nil {
		fields = append(fields, store.FieldURL)
	}
	if m.country != nil {
		fields = append(fields, store.FieldCountry)
	}
	if m.currency != nil {
		fields = append(fields, store.FieldCurrency)
	}
	if m.tax_reduction != nil {
		fields = append(fields, store.FieldTaxReduction)
	}
	if m.intl_shipping_fee != nil {
		fields = append(fields, store.FieldIntlShippingFee)
	}
	if m.intl_free_shipping_price != nil {
		fields = append(fields, store.FieldIntlFreeShippingPrice)
	}
	if m.domestic_shipping_fee != nil {
		fields = append(fields, store.FieldDomesticShippingFee)
	}
	if m.domestic_free_shipping_price != nil {
		fields = append(fields, store.FieldDomesticFreeShippingPrice)
	}
	if m.delivery_agency != nil {
		fields = append(fields, store.FieldDeliveryAgency)
	}
	if m.broker_fee != nil {
		fields = append(fields, store.FieldBrokerFee)
	}
	if m.ddp != nil {
		fields = append(fields, store.FieldDdp)
	}
	if m.updated_at != nil {
		fields = append(fields, store.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StoreMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case store.FieldStoreName:
		return m.StoreName()
	case store.FieldURL:
		return m.URL()
	case store.FieldCountry:
		return m.Country()
	case store.FieldCurrency:
		return m.Currency()
	case store.FieldTaxReduction:
		return m.TaxReduction()
	case store.FieldIntlShippingFee:
		return m.IntlShippingFee()
	case store.FieldIntlFreeShippingPrice:
		return m.IntlFreeShippingPrice()
	case store.FieldDomesticShippingFee:
		return m.DomesticShippingFee()
	case store.FieldDomesticFreeShippingPrice:
		return m.DomesticFreeShippingPrice()
	case store.FieldDeliveryAgency:
		return m.DeliveryAgency()
	case store.FieldBrokerFee:
		return m.BrokerFee()
	case store.FieldDdp:
		return m.Ddp()
	case store.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StoreMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case store.FieldStoreName:
		return m.OldStoreName(ctx)
	case store.FieldURL:
		return m.OldURL(ctx)
	case store.FieldCountry:
		return m.OldCountry(ctx)
	case store.FieldCurrency:
		return m.OldCurrency(ctx)
	case store.FieldTaxReduction:
		return m.OldTaxReduction(ctx)
	case store.FieldIntlShippingFee:
		return m.OldIntlShippingFee(ctx)
	case store.FieldIntlFreeShippingPrice:
		return m.OldIntlFreeShippingPrice(ctx)
	case store.FieldDomesticShippingFee:
		return m.OldDomesticShippingFee(ctx)
	case store.FieldDomesticFreeShippingPrice:
		return m.OldDomesticFreeShippingPrice(ctx)
	case store.FieldDeliveryAgency:
		return m.OldDeliveryAgency(ctx)
	case store.FieldBrokerFee:
		return m.OldBrokerFee(ctx)
	case store.FieldDdp:
		return m.OldDdp(ctx)
	case store.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Store field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoreMutation) SetField(name string, value ent.Value) error {
	switch name {
	case store.FieldStoreName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreName(v)
		return nil
	case store.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case store.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case store.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case store.FieldTaxReduction:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxReduction(v)
		return nil
	case store.FieldIntlShippingFee:
		v, ok := value.(*schema.ShippingFee)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntlShippingFee(v)
		return nil
	case store.FieldIntlFreeShippingPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntlFreeShippingPrice(v)
		return nil
	case store.FieldDomesticShippingFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomesticShippingFee(v)
		return nil
	case store.FieldDomesticFreeShippingPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomesticFreeShippingPrice(v)
		return nil
	case store.FieldDeliveryAgency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryAgency(v)
		return nil
	case store.FieldBrokerFee:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrokerFee(v)
		return nil
	case store.FieldDdp:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDdp(v)
		return nil
	case store.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Store field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StoreMutation) AddedFields() []string {
	var fields []string
	if m.addtax_reduction != nil {
		fields = append(fields, store.FieldTaxReduction)
	}
	if m.addintl_free_shipping_price != nil {
		fields = append(fields, store.FieldIntlFreeShippingPrice)
	}
	if m.adddomestic_shipping_fee != nil {
		fields = append(fields, store.FieldDomesticShippingFee)
	}
	if m.adddomestic_free_shipping_price != nil {
		fields = append(fields, store.FieldDomesticFreeShippingPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StoreMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case store.FieldTaxReduction:
		return m.AddedTaxReduction()
	case store.FieldIntlFreeShippingPrice:
		return m.AddedIntlFreeShippingPrice()
	case store.FieldDomesticShippingFee:
		return m.AddedDomesticShippingFee()
	case store.FieldDomesticFreeShippingPrice:
		return m.AddedDomesticFreeShippingPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoreMutation) AddField(name string, value ent.Value) error {
	switch name {
	case store.FieldTaxReduction:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTaxReduction(v)
		return nil
	case store.FieldIntlFreeShippingPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIntlFreeShippingPrice(v)
		return nil
	case store.FieldDomesticShippingFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDomesticShippingFee(v)
		return nil
	case store.FieldDomesticFreeShippingPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDomesticFreeShippingPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Store numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StoreMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StoreMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StoreMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Store nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StoreMutation) ResetField(name string) error {
	switch name {
	case store.FieldStoreName:
		m.ResetStoreName()
		return nil
	case store.FieldURL:
		m.ResetURL()
		return nil
	case store.FieldCountry:
		m.ResetCountry()
		return nil
	case store.FieldCurrency:
		m.ResetCurrency()
		return nil
	case store.FieldTaxReduction:
		m.ResetTaxReduction()
		return nil
	case store.FieldIntlShippingFee:
		m.ResetIntlShippingFee()
		return nil
	case store.FieldIntlFreeShippingPrice:
		m.ResetIntlFreeShippingPrice()
		return nil
	case store.FieldDomesticShippingFee:
		m.ResetDomesticShippingFee()
		return nil
	case store.FieldDomesticFreeShippingPrice:
		m.ResetDomesticFreeShippingPrice()
		return nil
	case store.FieldDeliveryAgency:
		m.ResetDeliveryAgency()
		return nil
	case store.FieldBrokerFee:
		m.ResetBrokerFee()
		return nil
	case store.FieldDdp:
		m.ResetDdp()
		return nil
	case store.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Store field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StoreMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.products != nil {
		edges = append(edges, store.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StoreMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case store.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StoreMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedproducts != nil {
		edges = append(edges, store.EdgeProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StoreMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case store.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StoreMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproducts {
		edges = append(edges, store.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StoreMutation) EdgeCleared(name string) bool {
	switch name {
	case store.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StoreMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Store unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StoreMutation) ResetEdge(name string) error {
	switch name {
	case store.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown Store edge %s", name)
}
